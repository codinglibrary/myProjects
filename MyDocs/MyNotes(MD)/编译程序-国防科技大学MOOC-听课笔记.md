## 一、引论

### I.什么是编译程序

关键点：

翻译程序、编译程序、诊断编译程序（Diagnostic Compiler）、优化编译程序（Optimizing Compiler）、宿主机、目标机、交叉编译程序（Cross Compiler）、可变目标编译程序（Retargetable Compiler）

解释程序、编译vs.解释



### II.为什么要学习编译程序

1. 理解计算系统（不是计算机系统）
2. 设计计算系统
3. 训练计算思维（Computational Thinking）：抽象、自动化、分解、递归、权衡
4. 理论和实践的最好典范



### III.编译过程

词法分析——语法分析——中间代码生成——优化——目标代码生成

目标代码三种形式：汇编指令代码（需要进行汇编）、绝对指令代码（可直接运行）、可重新定位指令代码（需要链接）



### IV.编译程序的结构

1、编译程序总框：词法分析器——语法分析器——语义分析与中间代码生成器——优化段——目标代码生成器

<img src="https://gitee.com/green-wine/myProjects/raw/master/MyDocs/drawio/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%BB%E6%A1%86.svg" style="zoom:110%;" />

2、出错处理程序：把有关错误报告给用户

3、符号表

几个相关概念：

- 遍（PASS）
- 阶段
- 前端/后端

### V.编译程序的生成

第一，使用汇编语言或机器语言直接编写（较困难）

第二，使用另一个高级语言。利用已有的某种语言的编译程序实现另一语言的编译程序

第三，移植方法。把一种机器上的编译程序移植到另一种机器上

第四，自编译方式。

![](https://gitee.com/green-wine/myProjects/raw/master/MyDocs/drawio/%E8%87%AA%E7%BC%96%E8%AF%91%E6%96%B9%E5%BC%8F.svg)

## 二、高级程序设计语言概述

### I.常用的高级程序设计语言

| 语言      | 特点                   |
| --------- | ---------------------- |
| FORTRAN   | 数值计算               |
| COBOL     | 事务处理               |
| PASCAL    | 结构化程序设计         |
| LISP      | 函数式程序设计         |
| PROLOG    | 逻辑程序设计           |
| C         | 系统程序设计           |
| Smalltalk | 面向对象程序设计       |
| Java      | Internet应用，可移植性 |
| Python	  | 解释型              |



### II.程序设计语言的定义

1、语法：一组规则，用它可以形成和生产一个合式（well-formed）的程序。

1）词法规则：单词符号的形成规则。描述工具：有限自动机

2）语法规则：语法单位的形成规则。描述工具：上下文无关文法

二者定义了程序的形式结构

```
E -> i
E -> E+E
e -> E*E
E -> (E)
```

2、语义：是一组规则，用它定义一个程序的意义。

形式描述：操作语义，指称语义，代数语义。

3、语用（内容待补充）

4、功能和结构

程序语言的基本功能：描述数据和对数据的运算。

程序的层次结构：程序——子程序或分程序、过程、函数——语句——表达式——数据引用、运算符、函数调用

### III.高级程序设计语言的一般特性

#### 1、高级语言分类

强制式语言/过程式语言，应用式语言（LISP、ML），基于规则的语言（Prolog），面向对象语言（封装、继承、多态，Smalltalk）

#### 2、程序结构

FORTRAN：一个程序由一个住程序段和若干辅程序段组成。模块结构，没有嵌套和递归；各程序段可独立编译。

PASCAL：本身可以看成一个操作系统调用的过程，过程可以嵌套和递归。使用**最近嵌套原则**确定标识符的作用域

```
函数体内作用域是从它的声明点开始的。
```

JAVA：类，继承。

#### 3、数据类型

数据类型三要素：用于区别这种类型数据对象的**属性**；这种类型的数据对象可以具有的**值**；可以作用于这种类型的数据对象的**操作**

初等数据类型：数值类型（整形、实型、复数、双精度），逻辑类型（true、false），字符类型，指针类型

绑定：将标识符和名字一一对应起来，编译时绑定叫静态绑定，运行时绑定叫动态绑定。

#### 4、数据结构

+ 数组

  根据编译时能否确定其储存空间的大小分为可变数组和不可变数组；

  C、PASCAL是按行存放，FORTRAN是按列存放；

  内情向量：登记维数，各维的上、下限，首地址，以及数组（元素）的类型等信息。

- 记录

  由已知类型的数据组合在一起的一种结构。

  记录或者结构的元素，也叫域（field）；

  访问：复合名record.name

  存储：连续存放

- 字符串（符号处理、公式处理）、表格（本质上是一种记录结构）、线性表、栈

- 抽象数据类型：由数据集合、及其相关的操作组成。

  包括：1.数据对象集合；2.作用于这些数据对象的抽象运算的集合；3.这种类型对象的封装。

  举例：Ada通过程序包提供了数据封装的支持（规范说明，程序包体）；Smalltalk、C++、Java通过类来实现封装。

#### 5、（常见）语句与控制语句

表达式由运算量组成。形式：中缀、前缀、后缀

算符的优先次序：

- 一般的规定：PASCAL是左结合；FORTRAN对于满足左、右结合的算符可任取一种
- 代数性质

语句：

- 赋值语句（PASCAL，A:=B，左值代表存储单元的**地址**，右值存贮单元的**内容**）
- 控制语句：无条件转移语句、条件语句、循环语句、过程调用语句、返回语句
- 分类：执行语句，说明语句。简单语句、复合语句

### IV.高级程序设计语言的语法描述

#### 1、文法：是描述语言的语法结构的形式规则

#### 2、语法描述的几个基本概念

字母表：一个有穷字符集，记为∑。其中每个元素称为字符，∑上的字（也叫字符串）是指由∑中的字符所构成的一个有穷数列。不包含任何字符的序列称为空字，记为ε。用∑\*表示∑上的所有字的全体，包括空字ε。

∑\*的子集U和V的连接（积）定义为，
$$
UV=\{ \alpha\beta|\alpha\in U \verb'&' \beta\in V \} \\

\mbox{V自身的n次积记为}V^n,V^0=\{\epsilon\},V^{\*}\mbox{是V的闭包；}V^+\mbox{是V的正规闭包：}V^+=VV^{\*}
$$




#### 3、上下文无关文法G是一个四元组

$$
G=(V_T,V_N,S,P)
$$



其中依次是（终结符集合（非空），非终结符集合（非空），文法的开始符号，产生式集合（有限）），

每个产生式形式为：
$$
P\to\alpha, P\in V_N,\alpha\in(V_T\or V_N)^*
$$

```
推导的定义。（直接推出，*推出——经过0步或若干步推出，+推出+经过1步或若干步推出）
```

#### 4、句型、句子和语言。

假定G是一个文法，S是它的开始符号。如果S经0步或若干步推出α，则称α是一个**句型**。

仅含终结符号的句型是一个**句子**。

文法G所产生的句子的全体是一个**语言**，记为L(G)。
$$
L(G)=\{\alpha|S\overset{+}{\Rightarrow}\alpha,\alpha\in V_T^*\}
$$

#### 5、语法树（最左推导和最右推导）

- ①父子节点可以同名；
- ②语法树并不反映结点产生的先后顺序，只反映语法符号的定义或者说是构成关系。是不同推导过程的共性抽象。

文法的二义性：如果一个文法存在某个句子对应两颗不同的语法树，则说这个文法是二义的。（即一个句型对应两颗语法树）

语言的二义性：如果它不存在无二义的文法，则该语言是二义的。

```
二义的根源来自语言本身而不是文法。
```

```
问题：如何判定一个文法不是二义的？
二义性问题是不可判定问题，即不存在一个算法在有限步骤内，确切地判定一个文法是否是二义的。
但可以找到一组无二义文法的充分条件。
```

#### 6、形式语言鸟瞰：0,1,2,3型

乔姆斯基形式语言体系，将文法分成以下四种类型。他们都由四部分组成，但对产生式的限制有所不同。

**<u>0型</u>**（短语文法，图灵机）产生式形如：
$$
\alpha\to\beta
$$
其中：
$$
\alpha\in(V_T\or V_N)^*\mbox{,且至少含有一个非终结符；}\beta\in(V_T\or V_N)^*
$$
**<u>1型</u>**（上下文有关文法，线性界限自动机）产生式形如：
$$
\alpha\to\beta
$$
其中（在0型基础上）：
$$
|\alpha|\leqslant|\beta|,\mbox{仅S}\to\varepsilon\mbox{例外}
$$
**<u>2型</u>**（上下文无关文法，非确定下推自动机）产生式形如：
$$
A\to\beta
$$
其中（在1型基础上）：
$$
A\in V_N;\beta\in(V_T\or V_N)^*
$$
**<u>3型</u>**（正规文法，有限自动机）产生式形如：
$$
A\to\alpha B \quad or\quad A\to\alpha \mbox{（右线型文法）}\\
A\to B\alpha \quad or\quad A\to\alpha \mbox{（左线型文法）}
$$
其中（在2型基础上）（右线性文法）：
$$
\alpha\in V_T^*;A,B\in V_N
$$
总结，四种类型文法描述能力比较

<img src="https://gitee.com/green-wine/myProjects/raw/master/MyDocs/drawio/%E6%96%87%E6%B3%95%E8%83%BD%E5%8A%9B%E6%AF%94%E8%BE%83.svg" alt="img" style="zoom:120%;" />

```
一个程序设计语言的大部分的约束都是可以用上下文无关文法来描述，至于超出上下文无关文法甚至超出上下文有关文法能力的那部分语言约束，都合并到语义分析里去做。
——权衡思维：理论研究重在探寻问题求解的方法，对于理论成果的研究运用又需要在能力和运用中作出权衡。
```

## 三、词法分析

### I.词法分析器的功能

从左至右逐个字符地对源程序进行扫描，产生一个个单词符号。

输入源程序、输出单词符号（基本字、标识符、常数、运算符、界符）。输出的单词符号的标识形式<单词种类，单词自身的值>。

另外，词法分析作为一个独立的阶段，但不一定作为单独的一遍。在整个编译阶段中，是以语法分析器为核心的，每当语法分析器运行不下去（需要输入单词符号时，调用词法分析子过程获取新的字符），二者关系如下：

![img](https://gitee.com/green-wine/myProjects/raw/master/MyDocs/drawio/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8.svg)

### II.词法分析器的设计

#### 1、词法分析器的结构

预处理子程序（提出无用的空白、跳格、回车和换行等编辑性字符；区分标号区，捻接续行和给出句末符等），输入缓冲区，扫描器，扫描缓冲区（有两个指针：起点指示器、搜索指示器，另外为了避免一个缓冲区无法一次性装下字符串，故两个半区互补使用，并限制字符串最大长度为一个半区的长度），几者关系如下：

![](https://gitee.com/green-wine/myProjects/raw/master/MyDocs/drawio/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84.svg)

几点限制——不必使用超前搜索

- 所有基本字都是保留字;用户不能用它们作自己的标识符

- 基本字作为特殊的标识符来处理，使用保留字表

- 如果基本字、标识符和常数(或标号)之间没有确定的运算符或界符作间隔，则必须使用一个空白符作间隔

#### 2、状态转换图

可用于识别（或接受）一定的字符串：若存在一条从初态到某一终态的道路，且这条路上所有弧上的标记符连接成的字等于α，则称α被该状态转换图所**识别(接受)**。

如下是一个状态转换图的示例，用以识别标识符、保留字、常数等：

<img src="https://gitee.com/green-wine/myProjects/raw/master/MyDocs/drawio/%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE%E7%A4%BA%E4%BE%8B.jpg" alt="af" style="zoom:50%;" />

然后，是状态转换图的代码实现：（每个状态结点对应一小段程序）

- 不含回路的分叉结点——可用**case语句或者if-else语句**实现
- 含回路的状态结点——由一段**while结构和if语句**构成
- 终态结点——表示识别出某种单词符号，对应**返回**语句

### II. 正则表达式与有限自动机

#### 1. 正规集和正规表达式（正规式）

> 正规集和正规式的关系：
>
> 1、正规集可以用正规式表示；
>
> 2、正规式是表示正规集的一种方法；
>
> 3、一个字集合是正规集当且仅当它能用正规式表示

正规集和正规式的递归定义：对给定的字母表 Σ，

- ε和∅都是Σ上的正规式，它们所表示的正规集为{ε}和∅；

- 任何a∈Σ，a是Σ上的正规式，它所表示的正规集为{a};

- 假定e1和e2都是Σ上的正规式，它们所表示的正规集为L(e1)和L(e2)，则

  - (e1|e2)为正规式，它所表示的正规集为L(e1)∪L(e2)

  - (e1.e2)为正规式，它所表示的正规集为L(e1)L(e2)（不是乘，是连接运算）

  - (e1)\*为正规式，它所表示的正规集为(L(e1))\*（闭包运算）

仅由有限次使用上述三步骤而定义的表达式才是Σ上的正规式，仅由这些正规式表示的字集才是Σ上的正规集。

#### 2. 正规式的等价性

若两个正规式所表示的正规集相同，则称这两个正规式等价。 

对正规式，下列等价成立：

```matlab
e1|e2=e2|e1  			#交换律
e1|(e2|e3) = (e1|e2)|e3 #结合律
e1(e2e3) = (e1e2)e3		#结合律
e1(e2|e3) = e1e2|e1e3	#分配率
(e2|e3)e1 = e2e1|e3e1 	#分配率
eε=εe=e		
e1e2<>e2e1#说明：连接运算没有交换律
```

>举例，在程序设计语言中，
>
>标识符可以用正规式：letter(letter|digit)* 表示
>
>常数可以用正规式：digit(digit)* 表示

#### 3. 确定有限自动机

确定有限自动机（Deterministic Finite Automata, DFA）M是一个五元式 M=(S,Σ,f,S0,F)，其中：
$$
\begin{align*}
  & S:\mbox{有穷状态集}\\
  & \Sigma:输入字母表(有穷)\\ 
  & f:状态转换函数,为S\times\Sigma\to S的单值部分映射，f(s,a)=s'表示:当现行状态为s,输入字符为a时，将状态转换到下一状态s',s'称为s的一个后继状态\\
  & S_0\in S是唯一的一个初态\\
  & F\subseteq S:终态集(可空)\\
\end{align*}
$$
DFA这种五元组定义是状态转换图一种形式化描述。

#### 4. 非确定有限自动机

非确定有限自动机（Nondeterministic Finite Automata, NFA）M是一个五元式 M=(S,Σ,f,S0,F)，其中：
$$
\begin{align*}
  & S:\mbox{有穷状态集}\\
  & \Sigma:输入字母表(有穷)\\ 
  & f:状态转换函数,为S\times\Sigma^*\to 2^S的部分映射\\
  & S_0\in S是非空的初态集\\
  & F\subseteq S:终态集(可空)\\
\end{align*}
$$
DFA是NFA的特例。DFA非常容易用程序实现；NFA易读性更强，易于人工设计。

#### 5. 自动机重要理论

定义：对于任何两个有限自动机M和M'，如果L(M)=L(M')，则称M与M'\label{2}。

重要结论：判定两个自动机等价性的算法是存在的。

重要结论：确定有限自动机DFA与非确定有限自动机NFA识别能力相同。即对于每一个NFA M都存在一个DFA M'，使得L(M)=L(M')

### III.词法分析器的自动产生——LEX

#### 1. NFA转换为DFA

