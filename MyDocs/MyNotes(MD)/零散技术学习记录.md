[Toc]

***
###  Git

&emsp;&emsp;用于版本控制（Version Control System ）Git是分布式存储系统，GitHub和BitBucket都是Git的托管平台。    

&emsp;&emsp;以GitHub Desktop为例，GitHub Desktop是GitHub团队开发的可视化管理工具，可以以HTTP的方式通过账号密码连接GitHub或者SSH方式【未解决】，也可以连接BitBucket平台。    

&emsp;&emsp;整体架构可以分为云端（origin）和客户端（local）。初始时，客户端可以在本地创建新的仓库或者从云端Clone下来账号里已经存在的仓库。当在本地对项目做了更改，可以Commit到本地数据库，再Push到云端。本地端可以使用Pull将云端项目拉到本地。需要注意的是，本地更改后，如果Pull将会造成版本冲突的问题，就需要先Stash项目放到暂存箱，再拉下来云端版本，所以需要养成经常Pull的习惯。

#### 常用命令

```shell
git stash                                                 # 暂存当前修改，将所有至为HEAD状态
git stash list                                            # 查看所有暂存
git add .                                                 # 增加当前子目录下所有更改过的文件至index
git diff --cached                                         # 显示所有已添加index但还未commit的变更
git commit -m 'xxx'                                       # 提交 
git branch                                                # 显示本地分支
git push origin master                                    # 将当前分支push到远程master分支

git fetch                                                 # 获取所有远程分支（不更新本地分支，另需merge）
git merge origin/master                                   # 合并远程master分支至当前分支
```



```shell
git init                                                  # 初始化本地git仓库（创建新仓库）
git config --global user.name "xxx"                       # 配置用户名
git config --global user.email "xxx@xxx.com"              # 配置邮件
git config --global color.ui true                         # git status等命令自动着色
git config --global color.status auto
git config --global color.diff auto
git config --global color.branch auto
git config --global color.interactive auto
git config --global --unset http.proxy                    # remove  proxy configuration on git
git clone git+ssh://git@192.168.53.168/VT.git             # clone远程仓库
git status                                                # 查看当前版本状态（是否修改）
git add xyz                                               # 添加xyz文件至index
git add .                                                 # 增加当前子目录下所有更改过的文件至index
git commit -m 'xxx'                                       # 提交
git commit --amend -m 'xxx'                               # 合并上一次提交（用于反复修改）
git commit -am 'xxx'                                      # 将add和commit合为一步
git rm xxx                                                # 删除index中的文件
git rm -r *                                               # 递归删除
git log                                                   # 显示提交日志
git log -1                                                # 显示1行日志 -n为n行
git log -5
git log --stat                                            # 显示提交日志及相关变动文件
git log -p -m
git show dfb02e6e4f2f7b573337763e5c0013802e392818         # 显示某个提交的详细内容
git show dfb02                                            # 可只用commitid的前几位
git show HEAD                                             # 显示HEAD提交日志
git show HEAD^                                            # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本
git tag                                                   # 显示已存在的tag
git tag -a v2.0 -m 'xxx'                                  # 增加v2.0的tag
git show v2.0                                             # 显示v2.0的日志及详细内容
git log v2.0                                              # 显示v2.0的日志
git diff                                                  # 显示所有未添加至index的变更
git diff --cached                                         # 显示所有已添加index但还未commit的变更
git diff HEAD^                                            # 比较与上一个版本的差异
git diff HEAD -- ./lib                                    # 比较与HEAD版本lib目录的差异
git diff origin/master..master                            # 比较远程分支master上有本地分支master上没有的
git diff origin/master..master --stat                     # 只显示差异的文件，不显示具体内容
git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）
git branch                                                # 显示本地分支
git branch --contains 50089                               # 显示包含提交50089的分支
git branch -a                                             # 显示所有分支
git branch -r                                             # 显示所有原创分支
git branch --merged                                       # 显示所有已合并到当前分支的分支
git branch --no-merged                                    # 显示所有未合并到当前分支的分支
git branch -m master master_copy                          # 本地分支改名
git checkout -b master_copy                               # 从当前分支创建新分支master_copy并检出
git checkout -b master master_copy                        # 上面的完整版
git checkout features/performance                         # 检出已存在的features/performance分支
git checkout --track hotfixes/BJVEP933                    # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支
git checkout v2.0                                         # 检出版本v2.0
git checkout -b devel origin/develop                      # 从远程分支develop创建新本地分支devel并检出
git checkout -- README                                    # 检出head版本的README文件（可用于修改错误回退）
git merge origin/master                                   # 合并远程master分支至当前分支
git cherry-pick ff44785404a8e                             # 合并提交ff44785404a8e的修改
git push origin master                                    # 将当前分支push到远程master分支
git push origin :hotfixes/BJVEP933                        # 删除远程仓库的hotfixes/BJVEP933分支
git push --tags                                           # 把所有tag推送到远程仓库
git fetch                                                 # 获取所有远程分支（不更新本地分支，另需merge）
git fetch --prune                                         # 获取所有原创分支并清除服务器上已删掉的分支
git pull origin master                                    # 获取远程分支master并merge到当前分支
git mv README README2                                     # 重命名文件README为README2
git reset --hard HEAD                                     # 将当前版本重置为HEAD（通常用于merge失败回退）
git rebase
git branch -d hotfixes/BJVEP933                           # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）
git branch -D hotfixes/BJVEP933                           # 强制删除分支hotfixes/BJVEP933
git ls-files                                              # 列出git index包含的文件
git show-branch                                           # 图示当前分支历史
git show-branch --all                                     # 图示所有分支历史
git whatchanged                                           # 显示提交历史对应的文件修改
git revert dfb02e6e4f2f7b573337763e5c0013802e392818       # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818
git ls-tree HEAD                                          # 内部命令：显示某个git对象
git rev-parse v2.0                                        # 内部命令：显示某个ref对于的SHA1 HASH
git reflog                                                # 显示所有提交，包括孤立节点
git show HEAD@{5}
git show master@{yesterday}                               # 显示master分支昨天的状态
git log --pretty=format:'%h %s' --graph                   # 图示提交日志
git show HEAD~3
git show -s --pretty=raw 2be7fcb476
git stash                                                 # 暂存当前修改，将所有至为HEAD状态
git stash list                                            # 查看所有暂存
git stash show -p stash@{0}                               # 参考第一次暂存
git stash apply stash@{0}                                 # 应用第一次暂存
git grep "delete from"                                    # 文件中搜索文本“delete from”
git grep -e '#define' --and -e SORT_DIRENT
git gc
git fsck
```



***
### 泛型

&emsp;&emsp;可以使我们在编译时检查出错误，而不是运行时。
&emsp;&emsp;泛型将类型参数化，据此特性可以定义带泛型类型的类和方法。


***
### Spring

    Spring之前使用EJB。
    EJB (Enterprise Java Beans) 是基于分布式事务处理的企业级应用程序的组件。
    EJB是用于开发和部署多层结构的、分布式的、面向对象的Java应用系统的跨平台的构件体系结构。
&emsp;&emsp;在实际开发中，服务器端通常采用三层体系架构，分别为表现层（web）、业务逻辑层（service）、持久层（dao）。    

&emsp;&emsp;Spring 致力于 Java EE 应用各层的解决方案，对每一层都提供了技术支持。在表现层提供了与 Spring MVC、Struts2 框架的整合，在业务逻辑层可以管理事务和记录日志等，在持久层可以整合 MyBatis、Hibernate 和 JdbcTemplate 等技术。这就充分体现出 Spring 是一个全面的解决方案，对于已经有较好解决方案的领域，Spring 绝不做重复的事情。    

&emsp;&emsp;从某个程度上来看，Spring 框架充当了黏合剂和润滑剂的角色，能够将相应的 Java Web 系统柔顺地整合起来，并让它们更易使用。同时其本身还提供了声明式事务等企业级开发不可或缺的功能。    


***
### SOFA

&emsp;&emsp;SOFA 是蚂蚁金服自主研发的金融级分布式中间件，包含了构建金融级云原生架构所需的各个组件，包括微服务研发框架，RPC 框架，服务注册中心，分布式定时任务，限流/熔断框架，动态配置推送，分布式链路追踪，Metrics监控度量，分布式高可用消息队列，分布式事务框架，分布式数据库代理层等组件，是一套分布式架构的完整的解决方案，也是在金融场景里锤炼出来的最佳实践。

&emsp;&emsp;链接：    
&emsp;&emsp;[再探蚂蚁中间件：SOFA](https://www.jianshu.com/p/e3dca8d5e9ee)    
&emsp;&emsp;[SOFA源码学习](https://www.jianshu.com/p/ab3acb2bb518)    

***
### SOFABoot

SOFABoot 是蚂蚁集团开源的基于 Spring Boot 的研发框架，它在 Spring Boot 的基础上，提供了诸如 Readiness Check，上下文隔离，类隔离，日志空间隔离等等能力。在增强了 Spring Boot 的同时，SOFABoot 提供了让用户可以在 Spring Boot 中非常方便地使用 SOFA 中间件的能力。    
[GitHub:sofa-boot](https://github.com/sofastack/sofa-boot)


***
### Maven
#### 父工程的用处
1、统一管理jar包的版本，其依赖需要在子工程中定义才有效    
2、统一的依赖管理    
3、控制插件的版本    
4、聚合工程    

#### Maven中的依赖
&emsp;&emsp;dependency相对于dependencyManagement，所有生命在dependencies里的依赖都会自动引入，并默认被所有的子项目继承。    
&emsp;&emsp;dependencies即使在子项目中不写该依赖项，那么子项目仍然会从父项目中继承该依赖项（全部继承）    
&emsp;&emsp;dependencyManagement里只是声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖。如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom;另外如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。    

#### Maven中的聚合 
&emsp;&emsp;父工程可以做为聚合工程（使用module标签）（一般也是这样），但并非一定要在父工程里面做聚合，聚合与继承是两个不相干的概念，可以另外建一个工程做聚合。    
&emsp;&emsp;Maven 的聚合其实就是项目与子项目的表示，其存在的意义在于快速构建项目。例如我们有一个淘宝商城项目，这个项目有账号子项目和邮件子项目。在这个时候我们需要在 Maven 中表达这种项目归属关系，那么我们就可以用 Maven 的聚合来进行配置。
#### Maven中的继承
&emsp;&emsp;在Maven中，子项目是可以继承父项目中的依赖的，比如说我们有一个父项目maven-parent，该父项目拥有一个子项目A，如果在父项目中依赖了junit，那么在子项目A中即便是没有引入junit，在子项目中仍然能够使用junit，因为子项目天然继承了父项目中的junit依赖。    
#### 聚合和继承的关系
&emsp;&emsp;从上面可以看到多模块 Maven 项目中的聚合与继承其实是两个概念，其目的是完全不同的。聚合是为了方便快速构建项目，继承是为了消除重复配置。    
&emsp;&emsp;对于聚合模块来说，它知道哪些被聚合的模块（通过modules元素），但那些被聚合的模块不知道这个聚合模块的存在。    
&emsp;&emsp;对于继承关系的父 POM 来说，它不知道哪些子模块继承于它，但那些子模块都必须知道自己的父 POM 是什么。    
&emsp;&emsp;在实际项目中，大家会发现一个 pom 即是聚合 pom，又是父 pom，这么做主要是为了方便。    
#### Maven中的依赖传递
&emsp;&emsp;在Maven中，依赖是可以传递的，就是说假设存在三个项目，分别是项目A，项目B以及项目C，假设C依赖于B，B依赖于A，那么我们可以根据Maven项目依赖的特征不难推出项目C也依赖于A    

[Maven Tutorial ](https://www.tutorialspoint.com/maven/index.htm)    
[Maven – Welcome to Apache Maven](https://maven.apache.org/#welcome-to-apache-maven)    
[Maven 教程 | JAVA-TUTORIAL)](https://dunwu.github.io/java-tutorial/javatool/build/maven/)



***
### SSL\TLS协议

Secure Socket Layer：安全套接字    
Tranport Layer Secure：传输层安全

***
### 中间件

&emsp;&emsp;从传统的客户端-服务器的架构演变到分布式架构，中间件应运而生。    

&emsp;&emsp;从架构的纵向角度看，位于各类应用/服务与操作系统/数据库系统以及其他系统软件之间，主要解决分布式环境下数据传输、数据访问、应用调度、系统构建和系统集成、流程管理等问题，是分布式环境下支撑应用开发、运行和集成的平台，能够实现系统之间的互联互通，帮助用户高效开发应用软件。    

中间件发展至今分为几类：    

> + 基础中间件    
>    - **交易中间件:**    
>    是面向对象技术与分布式计算技术结合的产物，其高效地传递交易（事务）请求，协调事务的各个分支，保证事务的完整性，调度应用程序的运行，实现整个系统运行的高效性。交易中间件适用于联机交易系统，如银行业务系统、订票系统等，在金融、财税、电信等行业中得到广泛落地。    
>
>    - **消息中间件:**
>    解决了分布式计算环境下多个子系统间的消息通信问题。其建立网络异步通信的通道，实现不同或同一计算机系统的应用通信，为网络环境下分布式应用系统的开发和运行提供灵活、易用的支撑平台，通常用来在各个系统或者组件间发送消息数据。消息队列是消息中间件的一种实现方式。
>
>    - **应用服务器中间件:**    
>    主要应用于Web系统，位于客户浏览器和数据库之间，其主要作用为把商业逻辑（应用）曝露给客户端，同时为商业逻辑（应用）提供运行平台和系统服务，并管理对数据库的访问。应用服务器中间件为Web系统下的应用开发者提供了开发工具和运行平台。
> + 集成中间件    
>   伴随着网络技术的进一步发展，基础中间件难以解决业务跨部门、跨企业的互联互通问题，集成中间件应运而生，主要基于面向服务（Service Oriented Architecture，SOA）架构。在SOA架构下，Web Services是一种具体实现方式，所有具备价值的IT资源不论新旧，均能成为随取随用的IT资产，并将各种服务快速整合并开发为组合式应用。    
>
>   - **企业服务总线ESB**
>   其基于消息通信、智能路由、数据转换等技术，支持各种异构软件及业务模块以服务化方式进行通信，是一种综合的集成中间件。
>
>   - **物联网中间件**
>   - **工作流中间件**
>   - **其他各类型中间件**

***
### Zookeeper

Explanation:    
ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services. All of these kinds of services are used in some form or another by distributed applications.     
链接:[Zookeeper wiki](https://cwiki.apache.org/confluence/display/ZOOKEEPER/Index)

***
### ActiveMQ

Apache ActiveMQ® is the most popular open source, multi-protocol, Java-based message broker. 

---
### gitignore文件

#### 为什么要有.gitignore文件
&emsp;&emsp;项目中经常会生成一些Git系统不需要追踪(track)的文件。典型的是在编译生成过程中产生的文件或是编程器生成的临时备份文件。当然，你不追踪(track)这些文件，可以平时不用"git add"去把它们加到索引中。 但是这样会很快变成一件烦人的事，你发现项目中到处有未追踪(untracked)的文件; 这样也使"git add ." 和"gi commit -a" 变得实际上没有用处，同时"git status"命令的输出也会有它们。你可以在你的顶层工作目录中添加一个叫".gitignore"的文件，来告诉Git系统要忽略 掉哪些文件。    
#### 忽略文件原则    
&emsp;&emsp;忽略操作系统自动生成的文件，比如缩略图等；    
&emsp;&emsp;忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；    
&emsp;&emsp;忽略你自己的带有敏感信息的配置文件，比如存放指令的配置文件。    
#### 语法规范（熟悉正则很容易理解）    
空格或是以#开头的行即注释的将被忽略；    
    
    以斜杠 “/” 结尾表示目录；    
    以星号 “*” 通配多个字符；    
    以问号 “?” 通配单个字符；    
    以方括号 “[]” 包含单个字符的匹配列表；    
    以叹号 “!” 表示不忽略(跟踪)匹配到的文件或目录；    
    可以在前面添加斜杠 “/” 来避免递归,下列的例子中可以很明显的看出来与下一条的区别。    
配置文件示例
> **忽略 .a 文件**    
> *.a    
> **但否定忽略 lib.a, 尽管已经在前面忽略了 .a 文件**    
> !lib.a    
> **仅在当前文录下忽略 TODO 文件， 但不包括子目录下的 subdir/TODO**    
> /TODO    
> **忽略 build/ 文件夹下的所有文件**    
> build/    
> **忽略 doc/notes.txt, 不包括 doc/server/arch.txt**    
> doc/*.txt    
> **忽略在 doc/ 及其各子目录下的所有的 .pdf 文件**    
> doc/\*\*/*.pdf    

---
### Register Center
#### Why is there register center?


#### What is register center?


#### How does register center work?

---
### Sequence Register Center
#### Why is there sequence register center?    


#### What is sequence register center?


#### How does sequence register center work?

---
### Message Queue
#### Why is there message queue?


#### What is message queue?


#### How does message queue work?

---
### Redis
#### Why is there redis?


#### What is redis?


#### How does redis work?

### 服务之间的通信过程（eagle平台）
#### 几个重要概念
&emsp;&emsp;报文、通讯组件、任务处理组件
#### 过程
&emsp;&emsp;两个服务接口之间的通信是以报文为载体的。    
以x接口为例：接口调用者发送报文给接口，接口处理完后仍以该报文为载体返回结果。对x接口而言，该报文称为in报文；对调用者而言，该报文称为out报文。

### About Bussiness

#### Types of transactions?

#### Types of account?

+ Real account
+ Virtual account
#### Batch to open accounts
### JUnit
**JUnit** is a [unit testing](https://en.wikipedia.org/wiki/Unit_testing) [framework](https://en.wikipedia.org/wiki/Software_framework) for the [Java programming language](https://en.wikipedia.org/wiki/Java_(programming_language)). JUnit has been important in the development of [test-driven development](https://en.wikipedia.org/wiki/Test-driven_development), and is one of a family of [unit testing](https://en.wikipedia.org/wiki/Unit_testing) frameworks which is collectively known as [xUnit](https://en.wikipedia.org/wiki/XUnit) that originated with [SUnit](https://en.wikipedia.org/wiki/SUnit).

JUnit is linked as a [JAR](https://en.wikipedia.org/wiki/JAR_(file_format)) at compile-time. The latest version of the framework, JUnit 5, resides under package `org.junit.jupiter`. Previous versions JUnit 4 and JUnit 3 were under packages `org.junit` and `junit.framework`, respectively.

A research survey performed in 2013 across 10,000 Java projects hosted on GitHub found that JUnit (in a tie with [slf4j-api](https://en.wikipedia.org/wiki/SLF4J)), was the most commonly included external library. Each library was used by 30.7% of projects.

JUnit是一个开发源代码的Java测试框架，用于编写和运行可重复的测试。它是用于单元测试框架体系xUnit的一个实例（用于java语言）。它包括以下特性：

1、用于测试期望结果的断言（Assertion）

2、用于共享共同测试数据的测试工具

3、用于方便的组织和运行测试的测试套件

4、图形和文本的测试运行器

JUnit最初是由Erich Gamma（GoF之一）和Kent Beck（xp和refactor的先驱之一）编写的. 

需要说明的是junit一般是用来进行单元测试的，因此需要了解被测试代码的内部结构（即所谓的白盒测试），另外junit是在xp编程和重构 （refactor）中被极力推荐使用的工具，因为在实现自动单元测试的情况下可以大大的提高开发的效率，但是实际上编写测试代码也是需要耗费很多的时间 和精力的，那么使用这个东东好处到底在哪里呢？笔者认为是这样的：

1、对于xp编程而言，要求在编写代码之前先写测试，这样可以强制 你在写代码之前好好的思考代码（方法）的功能和逻辑，否则编写的代码很不稳定，那么你需要同时维护测试代码和实际代码，这个工作量就会大大增加。因此在 xp编程中，基本过程是这样的：构思－》编写测试代码－》编写代码－》测试，而且编写测试和编写代码都是增量式的，写一点测一点，在编写以后的代码中如果 发现问题可以较块的追踪到问题的原因，减小回归错误的纠错难度

2、对于重构而言，其好处和xp编程中是类似的，因为重构也是要求改一点测一点，减少回归错误造成的时间消耗。

3、 对于非以上两种情况，我们在开发的时候使用junit写一些适当的测试也是有必要的，因为一般我们也是需要编写测试的代码的，可能原来不是使用的 junit，如果使用junit，而且针对接口（方法）编写测试代码会减少以后的维护工作，例如以后对方法内部的修改（这个就是相当于重构的工作了）。另 外就是因为junit有断言功能，如果测试结果不通过会告诉我们那个测试不通过，为什么，而如果是想以前的一般做法是写一些测试代码看其输出结果，然后再 由自己来判断结果使用正确，使用junit的好处就是这个结果是否正确的判断是它来完成的，我们只需要看看它告诉我们结果是否正确就可以了，在一般情况下 会大大提高效率。

[原文链接](https://blog.csdn.net/ArduousBonze/article/details/2452283)



### Public cloud（IaaS、PaaS、SaaS）

#### IaaS

With **IaaS**, a provider supplies the basic compute, storage and networking infrastructure along with the [hypervisor](https://searchservervirtualization.techtarget.com/definition/hypervisor) -- the virtualization layer. Users must then create [virtual machines](https://searchservervirtualization.techtarget.com/definition/virtual-machine), install operating systems, support applications and data, and handle all of the configuration and management associated with those tasks. Examples of IaaS services are DigitalOcean, AWS and Google Compute Engine (GCE).

#### PaaS

With **PaaS**, a provider offers more of the application [stack](https://whatis.techtarget.com/definition/stack) than IaaS solutions, adding operating systems, middleware (such as databases) and other runtimes into the cloud environment. PaaS products include AWS Elastic Beanstalk and Google App Engine.

[PaaS(platform as a service)](https://searchcloudcomputing.techtarget.com/definition/Platform-as-a-Service-PaaS)

#### SaaS

With **SaaS**, a provider offers an entire application stack. Users simply log in and use the application that runs completely on the provider's infrastructure. Typically, SaaS applications are completely accessible via internet web browser. SaaS providers manage all IT resources. Examples of SaaS include Salesforce, Dropbox and Google Workspace.

### VBScript

#### 一些基本语法

注释：在要注释的语句前加上 ‘ 即可

#### 执行bat批处理的两种方式

1. 使用wscript的run方法

   ```vbscript
   Dim oShell,batFile
   batFile="你的脚本.bat"
   Set oShell = CreateObject("wscript.shell")
   oShell.run(batFile,0,ture) ' 第二个参数 0的意思是隐藏cmd界面，第三个参数是是否等待执行完成
   ```

2. 使用wscript的exec方法
	
	> exec方法可以获取控制台输出信息和控制台错误信息

参考链接：[WScript.Shell对象的 run()和exec()函数使用详解](https://blog.51cto.com/alany/1568375)

#### VB的界面设计

