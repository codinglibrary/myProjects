    说明：
    本笔记主要记录了编译器设计中使用的根本思想和方法论。
    使用的是机械工业出版社出版的《编译原理》，翻译于<<Compilers>>by Alfred V.Aho,etc.    
    ©青酒

# 第一章 引论
>     高级语言 --（编译程序）-- 汇编语言 --（汇编程序）-- 机器语言
>         +                                     + 
>         +--------------(解释程序) ------------+
>  源程序--预处理器--编译器--汇编器--链接器/加载器--目标机器代码
> 预处理器：把存储在不同文件中的源程序聚合在一起。把被称为宏的缩写语句转换为原始语句。
> 链接器：将多各可重定位的机器代码文件（包括库文件）连接到一起。并负责解决外部内存地址问题。
> 
## 1.1.语言处理器

编译器: 翻译器,将一种语言翻译成另一种语言再执行。  
解释器：利用用户提供的输入执行源程序指定的操作。  
    
    源到源的翻译器：把一种高级语言翻译成另一种高级语言的翻译器

***Problems:***  
    

    - 编译器和解释器的区别？
    - 在语言处理系统中，编译器产生汇编语言而不是机器语言的好处？
    - 使用C语言作为目标语言的好处？
    - 汇编器所要完成的任务？

## 1.2. 编译器的结构

A complier is divided into two part: Analyse Part , Synthesis Part.    
+  Analyse Part     
Source program is transfered into two parts in this phase : intermediate representation and symbols table.     

+ Synthesis Part    
Expected target program will be generated from intermediate representation and symbols table.    

### 1.2.1. Lexical Analysis 词法分析
*Input:*    
**Character stream** of source program.    

*Process:*    
Extract **lexeme**  ---- Compose into **token**.(Space will be ingored.)    

*Output:*    
Token stream.

任务：输入源程序，对构成源程序的字符串进行扫描和分解，识别出单词符号。

依循的原则：构词规则

描述工具：有限自动机

### 1.2.2. Parsing 语法分析    
*Process:*    
The first component of all of tokens compose into **intermediate representation with tree form** which show syntax archetecture of token stream.    

*Output:*    
Syntax tree.

任务：在词法分析的基础上，根据语法规则把单词符号串分解成各类**语法单位（语法范畴）**

描述工具：上下文无关文法

### 1.2.3. Semantic Analysis 语义分析
*Process:*    
Using syntax tree and symbols table, **check** if source program is idential to semantic defined by language.     
Collect the type information and put in symbols table or syntax tree.    
Check type of elements ,and if should will convert type.    
### 1.2.4. 生成中间代码
*Process:*    
Generate intermediate code such as three-address code.    

*Note:*    
The intermediate code should be generated easily.    
The intermediate code should easily convert to target language.    

任务：对各类语法单位按语言的语义进行初步翻译。

依循的原则：语义规则

描述工具：属性文法

中间代码：三元式，四元式，数……

### 1.2.5. Optimization 代码优化
*Process:*    
The machine independent step tries to improve intermediate code so that generate perfect target code.    

任务：对前阶段产生的中间代码进行加工变换，以期在最后阶段产生更高效的

### 1.2.6. Code Generate 生成目标代码
*Process:*    
Map intermediate code to target code.    

*Note:*    
A vital aspect in the phase is allocating properly registers that reserve value.    


## 1.3.程序设计语言的发展历程
### 1.3.1 走向高级程序设计语言
机器指令--- 早期汇编（机器指令的助记表示） --- 中期汇编（加入了宏指令） --- 汇编语言 --- 早期高级语言（面向科学计算的Fortran，面向商业数据处理的Cobol，用于符号计算的Lisp）    

当前有几千种程序语言，可以按照下面的方式分类：    
+ 按照‘代’来分类
    - 第一代语言是机器语言    
    - 第二代语言是汇编语言    
    - 第三代语言是Fortran、Cobol、Lisp、C、C++、C#及Java这样的高级程序设计语言
    - 第四代是为特定应用设计的语言，比如用于生成报告的NOMAD，用于数据库查询的SQL和用于文本排版的Postscript    
    - 第五代语言是基于逻辑和约束的语言，比如Prolog和OPS5        
+ 另一种分类方式
    - 强制式语言：程序中指明**如何完成**一个计算任务的语言，例如C、C++、C#、Java。    
    - 声明式语言：程序中指明要**进行哪些计算**的语言，例如ML、Haskell这样的函数式语言，Prolog这样的约束逻辑语言。    
+ 其他分类方式
    - 冯·诺伊曼语言指以冯·诺依曼计算机体系结构为计算模型的程序设计语言，比如C、Fortran。
    - 面向对象语言：C++、C#、Java、Ruby。    
    - 脚本语言是具有高层次运算符的解释型语言，比如Awk、JavaScript、Perl、PHP、Python、Ruby、Tcl。脚本语言编写的程序要比其他等价程序短很多。

### 1.3.2. 对编译器的影响
编译器的设计者不仅需要跟踪一门高级语言的根本特征，还需要设计出新的编译算法，以便尽可能地利用新硬件的能力。    

在构建一个计算机之前，编译器会被用做评价一个体系结构概念的工具。    

<u>**“编译器必须能够翻译用源程序书写的所有程序。这样的程序的集合通常是无穷的。为一个源程序生成最佳目标的问题一般来说是不可判定的。因此，编译器的设计者必须做出折中处理，确定解决哪些问题，使用哪些启发式信息，以便解决高效代码生成的问题。”**</u>
## 1.4.构建一个编译器的相关科学
### 1.4.1. 编译器设计和实现中的建模
+ 如何设计正确的数学模型，选择正确的算法。（需要考虑对*通用性及功能的要求与简单性及有效性之间的平衡*。    
    > 有穷状态自动机（描述此法单位，第三章）    
    > 正则表达式（描述词法单位，第三章）    
    > 上下文无关文法（描述语法结构，第四章）    
    > 树形结构（第五章）    

### 1.4.2. 代码优化的科学
应用严格的**数学基础**，我们能可以证明一个优化是正确的，并且对所有可能的输入都产生预期的效果。需要图、矩阵、线性规划之类的模型。    
（第九章开始）
## 1.5.编译技术的应用
### 1.5.1. 高级程序设计语言的实现

### 1.5.2. 针对计算机体系结构的优化

### 1.5.3. 新计算机体系结构的设计
+ RISC（精简指令集计算机），CISC（复杂指令集计算机）    
    > PowerPC、SPARC、MIPS、Alpha、PA-RISC（都是基于RISC）    
    > x86体系结构（具有CISC指令集）    
+ 专用体系结构    
    > 数据流机器    
    > 向量机    
    > VLIW（非常长指令字）机器    
    > SIMD（单指令，多数据）处理器阵列    
    > 心动阵列（systolic array）    
    > 共享内存的多处理器    
    > 分布式内存的多处理器    

### 1.5.4. 程序翻译
+ 二进制翻译    
  
    > 把一个机器的二进制代码翻译成另一个机器的二进制代码    
+ 硬件合成   
  
    > 比如Verilog和VHDL
+ 数据查询解释器    
  
    > 比如SQL    
+ 编译然后模拟    

### 1.5.5. 软件生产率工具
+ 类型检查    

+ 边界检查    

+ 内存管理工具

## 1.6.程序设计语言基础
### 1.6.1. 静态和动态的区别
***keys：*** 静态策略和动态策略，静态作用域和动态作用域。
### 1.6.2. 环境与状态
环境：从名字到存储位置的映射。    
状态：从内存位置到值的映射。    
### 1.6.3. 静态作用域和块结构
***keys：*** 名字、标识符和变量，过程、函数和方法。

### 1.6.4. 显示访问控制
***keys：*** 声明和定义。
### 1.6.5. 动态作用域
如果一个作用域策略依赖于一个或多个只有在程序执行时刻才能知道的因素，它就是动态的。    
动态作用域是指：对于一个名字x的使用指向的是最近被调用但还没有终止且声明了x的过程中的这个声明。    

静态作用域和动态作用域的类别：*<u>从某种意义上讲，动态规则处理时间的方式类似于静态作用域处理空间的方式。</u>*
### 1.6.6. 参数传递规则
+ 值调用    
+ 引用调用
+ 名调用（今天已不再采用）    

### 1.6.7. 别名
有可能两个形式参数指向同一个位置，这样的变量称为另一个变量的别名。    
很多情况下我们必须在确认某些变量相互之间不是别名之后才可以优化程序。

    1 Chapter is over.
    ©青酒

# 第二章 一个简单的语法制导翻译器

    2 Chapter is over.
    ©青酒
# 第三章 词法分析

    3 Chapter is over.
    ©青酒
# 第四章 语法分析

    4 Chapter is over.
    ©青酒
# 第五章 语法制导的翻译

    5 Chapter is over.
    ©青酒
# 第六章 中间代码生成

    6 Chapter is over.
    ©青酒
# 第七章 运行时刻环境

    7 Chapter is over.
    ©青酒
# 第八章 代码生成

    8 Chapter is over.
    ©青酒
# 第九章 机器无关优化

    9 Chapter is over.
    ©青酒
# 第十章 指令级并行性

    10 Chapter is over.
    ©青酒
# 第十一章 并行性和局部性优化

    11 Chapter is over.
    ©青酒
# 第十二章 过程间分析

    12 Chapter is over.
    ©青酒